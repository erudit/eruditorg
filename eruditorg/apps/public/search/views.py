# -*- coding: utf-8 -*-

import json

from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect
from django.views.generic import View
from django.views.generic.base import TemplateResponseMixin
from django.views.generic.edit import FormMixin
from django.utils.encoding import smart_text
from rest_framework.generics import ListAPIView
from rest_framework.response import Response

from erudit.models import EruditDocument
from erudit.serializers import EruditDocumentSerializer

from . import filters
from .forms import ResultsFilterForm
from .forms import ResultsOptionsForm
from .forms import SearchForm
from .pagination import EruditDocumentPagination
from .utils import get_search_elements


class EruditDocumentListAPIView(ListAPIView):
    authentication_classes = []
    pagination_class = EruditDocumentPagination
    queryset = EruditDocument.objects.all()
    search_engine_filter_backend = filters.EruditDocumentSolrFilter
    serializer_class = EruditDocumentSerializer

    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())

        # Applies the search engine filter backend in order to get a list of filtered
        # EruditDocument localidentifiers, a dictionnary contening the result of aggregations
        # that should be embedded in the final response object and a number of hits.
        docs_count, localidentifiers, aggregations_dict = self.search_engine_filter_backend() \
            .filter(self.request, queryset, self)

        # Paginates the results
        page = self.paginate(docs_count, localidentifiers, queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            response = self.get_paginated_response(serializer.data)
        else:  # pragma: no cover
            # This can happen if we pass page_size = 0
            serializer = self.get_serializer(queryset, many=True)
            response = Response(serializer.data)

        # Add aggregation data to the returned content
        response.data.update({'aggregations': aggregations_dict})

        return response

    def paginate(self, docs_count, localidentifiers, queryset):
        return self.paginator.paginate(
            docs_count, localidentifiers, queryset, self.request, view=self)


class AdvancedSearchView(TemplateResponseMixin, FormMixin, View):
    """ Displays the search form in order to perform advanced searches for Érudit documents. """
    form_class = SearchForm
    http_method_names = ['get', ]
    template_name = 'public/search/advanced_search.html'

    def get(self, request, *args, **kwargs):
        form = self.get_form()
        if request.GET:
            form.is_valid()
        return self.render_to_response(self.get_context_data(form=form))

    def get_form_kwargs(self):
        kwargs = {'initial': self.get_initial(), 'prefix': self.get_prefix()}
        if self.request.GET:
            kwargs.update({'data': self.request.GET})
        return kwargs


class SearchResultsView(TemplateResponseMixin, FormMixin, View):
    """ Display the results associated with a search for Érudit documents. """
    filter_form_class = ResultsFilterForm
    http_method_names = ['get', ]
    options_form_class = ResultsOptionsForm
    search_form_class = SearchForm
    template_name = 'public/search/results.html'

    def get(self, request, *args, **kwargs):
        # This view works only for GET requests
        search_form = self.get_search_form()
        options_form = self.get_options_form()
        search_form_valid, options_form_valid = search_form.is_valid(), options_form.is_valid()
        if search_form_valid and options_form_valid:
            return self.forms_valid(search_form, options_form)
        else:
            return self.forms_invalid(search_form, options_form)

    def get_search_form(self):
        """ Returns an instance of the search form to be used in this view. """
        return self.search_form_class(**self.get_search_form_kwargs())

    def get_search_form_kwargs(self):
        """ Returns the keyword arguments for instantiating the search form. """
        form_kwargs = {}

        if self.request.method == 'GET':
            form_kwargs.update({'data': self.request.GET, })
        return form_kwargs

    def get_filter_form(self, **kwargs):
        """ Returns an instance of the filter form to be used in this view. """
        return self.filter_form_class(**self.get_filter_form_kwargs(**kwargs))

    def get_filter_form_kwargs(self, **kwargs):
        """ Returns the keyword arguments for instantiating the filter form. """
        form_kwargs = {}
        form_kwargs.update(kwargs)

        if self.request.method == 'GET':
            form_kwargs.update({'data': self.request.GET, })
        return form_kwargs

    def get_options_form(self):
        """ Returns an instance of the options form to be used in this view. """
        return self.options_form_class(**self.get_options_form_kwargs())

    def get_options_form_kwargs(self):
        """ Returns the keyword arguments for instantiating the options form. """
        form_kwargs = {}

        if self.request.method == 'GET':
            form_kwargs.update({'data': self.request.GET, })
        return form_kwargs

    def get_context_data(self, **kwargs):
        context = super(SearchResultsView, self).get_context_data(**kwargs)
        results = context.get('results', None)

        if results:
            context['main_qterm'] = self.request.GET.get('basic_search_term', '')
            context['start_at'] = (results['pagination']['current_page'] - 1) \
                * results['pagination']['page_size']
            context['search_elements'] = get_search_elements(self.request)

        return context

    def forms_valid(self, search_form, options_form):
        # The form is valid so we have to retrieve the list of results by using the API view
        # returning EruditDocument documents.
        list_view = EruditDocumentListAPIView.as_view()
        request = self.request
        request.GET = request.GET.copy()  # A QueryDict is immutable
        request.GET.setdefault('format', 'json')
        results_data = list_view(request).render().content
        results = json.loads(smart_text(results_data))

        # Initializes the filters form here in order to display it using choices generated from the
        # aggregations embedded in the results.
        filter_form = self.get_filter_form(api_results=results)

        return self.render_to_response(self.get_context_data(
            search_form=search_form, filter_form=filter_form, options_form=options_form,
            results=results, documents=results.get('results')))

    def forms_invalid(self, search_form, options_form):
        return HttpResponseRedirect(
            '{}?{}'.format(reverse('public:search:advanced_search'), self.request.GET.urlencode()))
